"use client";

// generated by chat gpt
// whole file based on this blog: https://thoughtbot.com/blog/html5-canvas-snake-game

import React, { useEffect, useRef, useState } from "react";
import { User } from "@/app/lib/definitions";
import { FaPlay, FaPause, FaRedo, FaTrash, FaSkull, FaPlayCircle } from "react-icons/fa";
import { useLocalStorage } from "@/app/lib/hooks/useStorage";

const gridSize = 10;
const canvasWidth = 400;
const canvasHeight = 400;

export default function SnakeHome({ user }: { user: User }) {
	const canvasRef = useRef<HTMLCanvasElement | null>(null);
	const intervalRef = useRef<NodeJS.Timeout | null>(null);

	const [snakeBody, setSnakeBody] = useState<[number, number][]>([]);
	const [snakeLength, setSnakeLength] = useState(3);
	const [direction, setDirection] = useState<"up" | "down" | "left" | "right">("right");
	const [food, setFood] = useState<[number, number]>([100, 100]);
	const [running, setRunning] = useState(false);
	const [gameState, setGameState] = useState<"idle" | "running" | "paused" | "over">("idle");
	const [score, setScore] = useState(0);

	// --- Draw snake & food
	useEffect(() => {
		const canvas = canvasRef.current;
		if (!canvas) return;
		const ctx = canvas.getContext("2d");
		if (!ctx) return;

		ctx.clearRect(0, 0, canvas.width, canvas.height);

		ctx.fillStyle = "rgb(200,0,0)";
		snakeBody.forEach(([x, y]) => ctx.fillRect(x, y, gridSize, gridSize));

		ctx.fillStyle = "rgb(10,100,0)";
		ctx.fillRect(food[0], food[1], gridSize, gridSize);
	}, [snakeBody, food]);

	// --- Game loop
	useEffect(() => {
		if (!running) return;
		setGameState("running");
		intervalRef.current = setInterval(moveSnake, 120);
		return () => {
			if (intervalRef.current) clearInterval(intervalRef.current);
		};
	}, [snakeBody, direction, running]);

	// --- Keyboard controls
	useEffect(() => {
		const handleKey = (e: KeyboardEvent) => {
			if (!running) return;
			switch (e.key) {
				case "ArrowUp":
					if (direction !== "down") setDirection("up");
					break;
				case "ArrowDown":
					if (direction !== "up") setDirection("down");
					break;
				case "ArrowLeft":
					if (direction !== "right") setDirection("left");
					break;
				case "ArrowRight":
					if (direction !== "left") setDirection("right");
					break;
			}
		};
		window.addEventListener("keydown", handleKey);
		return () => window.removeEventListener("keydown", handleKey);
	}, [direction, running]);

	function moveSnake() {
		if (snakeBody.length === 0) return;
		const head = snakeBody[snakeBody.length - 1];
		let newHead: [number, number] = [...head];

		switch (direction) {
			case "up":
				newHead = [head[0], head[1] - gridSize];
				break;
			case "down":
				newHead = [head[0], head[1] + gridSize];
				break;
			case "left":
				newHead = [head[0] - gridSize, head[1]];
				break;
			case "right":
				newHead = [head[0] + gridSize, head[1]];
				break;
		}

		if (
			newHead[0] < 0 ||
			newHead[1] < 0 ||
			newHead[0] >= canvasWidth ||
			newHead[1] >= canvasHeight ||
			snakeBody.some(([x, y]) => x === newHead[0] && y === newHead[1])
		) {
			gameOver();
			return;
		}

		let newBody = [...snakeBody, newHead];
		if (newHead[0] === food[0] && newHead[1] === food[1]) {
			setSnakeLength((len) => len + 1);
			setScore((s) => s + 10); // ✅ Increase score
			spawnFood(newBody);
		} else {
			while (newBody.length > snakeLength) newBody.shift();
		}
		setSnakeBody(newBody);
	}

	function spawnFood(currentSnake: [number, number][]) {
		let newFood: [number, number];
		do {
			newFood = [
				Math.floor(Math.random() * (canvasWidth / gridSize)) * gridSize,
				Math.floor(Math.random() * (canvasHeight / gridSize)) * gridSize,
			];
		} while (currentSnake.some(([x, y]) => x === newFood[0] && y === newFood[1]));
		setFood(newFood);
	}

	function startGame() {
		setSnakeBody([
			[50, 50],
			[60, 50],
			[70, 50],
		]);
		setDirection("right");
		setSnakeLength(3);
		spawnFood([
			[50, 50],
			[60, 50],
			[70, 50],
		]);
		setScore(0); // ✅ Reset score
		setRunning(true);
		setGameState("running");
	}

	function pauseGame() {
		setRunning(false);
		setGameState("paused");
	}

	function unPauseGame() {
		setRunning(true);
		setGameState("running");
	}

	function restartGame() {
		setRunning(false);
		startGame();
	}

	function clearCanvas() {
		const canvas = canvasRef.current;
		if (!canvas) return;
		const ctx = canvas.getContext("2d");
		if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
		setSnakeBody([]);
		setRunning(false);
		setGameState("idle");
		setScore(0);
	}

	function gameOver() {
		setRunning(false);
		setGameState("over");
	}

	const [disableInstructions, setDisableInstructions] = useLocalStorage("disableInstructions-tictactoe");

	return (
		<>
			<div className="flex flex-col items-center gap-4 relative flex-1 justify-center">
				{!disableInstructions && (
					<div className="w-full h-fit absolute top-0 flex justify-between left-0 right-0 py-1 px-2 items-center text-sm font-semibold bg-yellow-200 text-yellow-900">
						<p className="text-center">Use the arrow keys to move the snake around</p>
						<button onClick={() => setDisableInstructions(true)} className="size-6 text-center !p-0 text-xs">
							X
						</button>
					</div>
				)}

				{/* --- Game Canvas --- */}
				{/* --- Score Display --- */}
				<p className="text-lg font-semibold text-gray-700">
					Score: <span className="text-green-600">{score}</span>
				</p>

				<div className="relative">
					<canvas
						ref={canvasRef}
						width={canvasWidth}
						height={canvasHeight}
						className="border-4 border-primary rounded-md bg-contrast"
					></canvas>

					{/* --- Overlay for idle, paused, and over states --- */}
					{gameState !== "running" && (
						<div className="absolute inset-0 flex flex-col items-center justify-center bg-black/50 text-white rounded-md space-y-3">
							{gameState === "over" && (
								<>
									<FaSkull className="text-4xl text-red-400 animate-pulse" />
									<p className="text-xl font-bold">Game Over</p>
									<p className="text-sm">Score: {score}</p>
								</>
							)}

							{gameState === "paused" && (
								<>
									<FaPause className="text-4xl text-yellow-300" />
									<p className="text-lg">Paused</p>
								</>
							)}

							{gameState === "idle" && (
								<>
									<FaPlay className="text-4xl text-green-400" />
									<p className="text-lg">Press Start to Play</p>
								</>
							)}
						</div>
					)}
				</div>

				{/* --- Controls with icons --- */}
				<div className="flex gap-3 mt-2">
					<button className="btn btn-secondary flex items-center gap-2" onClick={startGame}>
						<FaPlay /> Start
					</button>
					<button
						className="btn btn-secondary flex items-center gap-2"
						onClick={() => {
							if (gameState === "running") pauseGame();
							else if (gameState === "paused") unPauseGame();
						}}
						disabled={gameState === "idle" || gameState === "over"}
					>
						{gameState === "running" ? (
							<>
								<FaPause /> Pause
							</>
						) : gameState === "paused" ? (
							<>
								<FaPlayCircle /> Unpause
							</>
						) : (
							<>
								<FaPause /> Pause
							</>
						)}
					</button>

					<button className="btn btn-secondary flex items-center gap-2" onClick={restartGame}>
						<FaRedo /> Restart
					</button>
					<button className="btn btn-error flex items-center gap-2" onClick={clearCanvas}>
						<FaTrash /> Clear
					</button>
				</div>
			</div>

			<aside className="w-75 border-l border-contrast"></aside>
		</>
	);
}

// "use client";

// import React, { useEffect, useRef, useState } from "react";
// import { User } from "@/app/lib/definitions";

// const gridSize = 10;
// const canvasWidth = 400;
// const canvasHeight = 400;

// export default function SnakeHome({ user }: { user: User }) {
// 	const canvasRef = useRef<HTMLCanvasElement | null>(null);
// 	const intervalRef = useRef<NodeJS.Timeout | null>(null);

// 	const [snakeBody, setSnakeBody] = useState<[number, number][]>([]);
// 	const [snakeLength, setSnakeLength] = useState(3);
// 	const [direction, setDirection] = useState<"up" | "down" | "left" | "right">("right");
// 	const [food, setFood] = useState<[number, number]>([100, 100]);
// 	const [running, setRunning] = useState(false);

// 	// --- Draw everything
// 	useEffect(() => {
// 		const canvas = canvasRef.current;
// 		if (!canvas) return;
// 		const ctx = canvas.getContext("2d");
// 		if (!ctx) return;

// 		// Clear canvas
// 		ctx.clearRect(0, 0, canvas.width, canvas.height);

// 		// Draw snake
// 		ctx.fillStyle = "rgb(200,0,0)";
// 		snakeBody.forEach(([x, y]) => ctx.fillRect(x, y, gridSize, gridSize));

// 		// Draw food
// 		ctx.fillStyle = "rgb(10,100,0)";
// 		ctx.fillRect(food[0], food[1], gridSize, gridSize);
// 	}, [snakeBody, food]);

// 	// --- Snake movement logic
// 	useEffect(() => {
// 		if (!running) return;
// 		intervalRef.current = setInterval(moveSnake, 120);
// 		return () => {
// 			if (intervalRef.current) clearInterval(intervalRef.current);
// 		};
// 	}, [snakeBody, direction, running]);

// 	// --- Key controls
// 	useEffect(() => {
// 		const handleKey = (e: KeyboardEvent) => {
// 			if (!running) return;
// 			switch (e.key) {
// 				case "ArrowUp":
// 					if (direction !== "down") setDirection("up");
// 					break;
// 				case "ArrowDown":
// 					if (direction !== "up") setDirection("down");
// 					break;
// 				case "ArrowLeft":
// 					if (direction !== "right") setDirection("left");
// 					break;
// 				case "ArrowRight":
// 					if (direction !== "left") setDirection("right");
// 					break;
// 			}
// 		};
// 		window.addEventListener("keydown", handleKey);
// 		return () => window.removeEventListener("keydown", handleKey);
// 	}, [direction, running]);

// 	// --- Core movement
// 	function moveSnake() {
// 		if (snakeBody.length === 0) return;
// 		const head = snakeBody[snakeBody.length - 1];
// 		let newHead: [number, number] = [...head];

// 		switch (direction) {
// 			case "up":
// 				newHead = [head[0], head[1] - gridSize];
// 				break;
// 			case "down":
// 				newHead = [head[0], head[1] + gridSize];
// 				break;
// 			case "left":
// 				newHead = [head[0] - gridSize, head[1]];
// 				break;
// 			case "right":
// 				newHead = [head[0] + gridSize, head[1]];
// 				break;
// 		}

// 		// Wall collision
// 		if (
// 			newHead[0] < 0 ||
// 			newHead[1] < 0 ||
// 			newHead[0] >= canvasWidth ||
// 			newHead[1] >= canvasHeight ||
// 			snakeBody.some(([x, y]) => x === newHead[0] && y === newHead[1])
// 		) {
// 			gameOver();
// 			return;
// 		}

// 		let newBody = [...snakeBody, newHead];
// 		// Eat food
// 		if (newHead[0] === food[0] && newHead[1] === food[1]) {
// 			setSnakeLength((len) => len + 1);
// 			spawnFood(newBody);
// 		} else {
// 			while (newBody.length > snakeLength) newBody.shift();
// 		}
// 		setSnakeBody(newBody);
// 	}

// 	function spawnFood(currentSnake: [number, number][]) {
// 		let newFood: [number, number];
// 		do {
// 			newFood = [
// 				Math.floor(Math.random() * (canvasWidth / gridSize)) * gridSize,
// 				Math.floor(Math.random() * (canvasHeight / gridSize)) * gridSize,
// 			];
// 		} while (currentSnake.some(([x, y]) => x === newFood[0] && y === newFood[1]));
// 		setFood(newFood);
// 	}

// 	function startGame() {
// 		setSnakeBody([
// 			[50, 50],
// 			[60, 50],
// 			[70, 50],
// 		]);
// 		setDirection("right");
// 		setSnakeLength(3);
// 		spawnFood([
// 			[50, 50],
// 			[60, 50],
// 			[70, 50],
// 		]);
// 		setRunning(true);
// 	}

// 	function pauseGame() {
// 		setRunning(false);
// 	}

// 	function unPauseGame() {
// 		setRunning(true);
// 	}

// 	function restartGame() {
// 		setRunning(false);
// 		startGame();
// 	}

// 	function clearCanvas() {
// 		const canvas = canvasRef.current;
// 		if (!canvas) return;
// 		const ctx = canvas.getContext("2d");
// 		if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
// 		setSnakeBody([]);
// 		setRunning(false);
// 	}

// 	function gameOver() {
// 		setRunning(false);
// 		alert(`Game Over! Your score: ${(snakeLength - 3) * 10}`);
// 	}

// 	return (
// 		<div className="flex flex-col items-center gap-3">
// 			<canvas
// 				ref={canvasRef}
// 				width={canvasWidth}
// 				height={canvasHeight}
// 				className="border border-red-500 rounded-md"
// 			></canvas>

// 			<div className="flex gap-2">
// 				<button className="btn btn-secondary" onClick={startGame}>
// 					Start
// 				</button>
// 				<button className="btn btn-secondary" onClick={() => (running ? pauseGame() : unPauseGame())}>
// 					{running ? "Pause" : "Unpause"}
// 				</button>
// 				<button className="btn btn-secondary" onClick={restartGame}>
// 					Restart
// 				</button>
// 				<button className="btn btn-error" onClick={clearCanvas}>
// 					Clear Canvas
// 				</button>
// 			</div>
// 		</div>
// 	);
// }
