// generated by ChatGPT based on some code I got from github. But did not work as expected. I had been lazy and I need to leaarn properly.

"use client";

import { useToast } from "@/app/lib/hooks/useToast";
import { socket } from "@/app/lib/socket";
import { useEffect, useRef, useState, useCallback } from "react";
import { Socket } from "socket.io-client";

export default function Page() {
	const [roomId, setRoomId] = useState("");
	const [joinRoomId, setJoinRoomId] = useState("");
	const [incomingCalls, setIncomingCalls] = useState<string[]>([]);
	const [remoteSocketId, setRemoteSocketId] = useState<string | null>(null);
	const [callActive, setCallActive] = useState(false);
	// NEW: State to track Socket.io connection status
	const [isConnected, setIsConnected] = useState(false);

	const localVideoRef = useRef<HTMLVideoElement>(null);
	const remoteVideoRef = useRef<HTMLVideoElement>(null);
	const peerRef = useRef<RTCPeerConnection | null>(null);
	const localStreamRef = useRef<MediaStream | null>(null);
	const toast = useToast();
	const socketRef = useRef<Socket>(socket);

	// Function to set up a new RTCPeerConnection and its essential event listeners
	const initializePeerConnectionAndListeners = useCallback(() => {
		// Clean up the old peer connection first
		if (peerRef.current) {
			peerRef.current.close();
			peerRef.current = null;
		}

		const peer = new RTCPeerConnection({
			iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
		});

		// ICE Candidate Listener: Use remoteSocketId from the component's closure
		peer.onicecandidate = (event) => {
			// This entire function is recreated by useCallback whenever remoteSocketId changes,
			// ensuring event.candidate is sent to the correct ID.
			if (event.candidate && remoteSocketId) {
				socketRef.current?.emit("peer-updated", {
					candidate: event.candidate,
					to: remoteSocketId,
				});
			}
		};

		// Track Listener
		peer.ontrack = (event) => {
			if (remoteVideoRef.current && !remoteVideoRef.current.srcObject) {
				remoteVideoRef.current.srcObject = event.streams[0];
			}
		};

		peerRef.current = peer;
		console.log("RTCPeerConnection re-initialized.");
	}, [remoteSocketId]); // remoteSocketId ensures the onicecandidate function is up-to-date

	// Function to hang up and reset the component state
	const closeCall = useCallback(
		(shouldEmit: boolean = true) => {
			// Stop local media tracks
			localStreamRef.current?.getTracks().forEach((track) => track.stop());
			localStreamRef.current = null;

			// Clear video elements
			if (localVideoRef.current) localVideoRef.current.srcObject = null;
			if (remoteVideoRef.current) remoteVideoRef.current.srcObject = null;

			// Close peer connection
			peerRef.current?.close();

			// Notify other peer if this client initiated the hang-up
			if (shouldEmit && remoteSocketId) {
				socketRef.current?.emit("call-ended", remoteSocketId);
			}

			// Reset state
			setCallActive(false);
			setRemoteSocketId(null);
			setIncomingCalls([]);

			// RE-INITIALIZE peer connection to be ready for the next call
			initializePeerConnectionAndListeners();

			toast({ title: "Call Ended", mode: "info", subtitle: "" });
		},
		[remoteSocketId, initializePeerConnectionAndListeners, toast]
	);

	// Function to get local stream and create an offer (used by the caller/room creator)
	const initializePeerConnection = async (targetSocketId: string) => {
		// Must call setRemoteSocketId BEFORE creating offer/setting local stream
		// to ensure initializePeerConnectionAndListeners has the correct ID when it runs.
		setRemoteSocketId(targetSocketId);
		if (!peerRef.current) return;

		try {
			// 1️⃣ Get local media and save to ref
			const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
			localStreamRef.current = localStream;
			if (localVideoRef.current) localVideoRef.current.srcObject = localStream;

			// 2️⃣ Add tracks
			localStream.getTracks().forEach((track) => peerRef.current?.addTrack(track, localStream));

			// 3️⃣ Create offer
			const localOffer = await peerRef.current.createOffer();
			await peerRef.current.setLocalDescription(localOffer);

			// 4️⃣ Emit offer to remote peer
			socketRef.current?.emit("offer-request", { fromOffer: localOffer, to: targetSocketId });

			setCallActive(true);
			toast({ title: "Peer Connection Started", mode: "info", subtitle: `Connecting to ${targetSocketId}` });
		} catch (err) {
			toast({ title: "Error initializing call", mode: "negative", subtitle: String(err) });
			console.error(err);
		}
	};

	// --- EFFECT HOOK FOR LIFECYCLE MANAGEMENT AND SOCKET LISTENERS ---

	useEffect(() => {
		// Initial setup on mount
		initializePeerConnectionAndListeners();

		// ⚠️ NEW: Socket Connection Status Listeners
		socketRef.current.on("connect", () => {
			setIsConnected(true);
			console.log("Socket.io connected:", socketRef.current.id);
		});
		socketRef.current.on("disconnect", () => {
			setIsConnected(false);
			console.log("Socket.io disconnected.");
			closeCall(false); // Clean up if disconnected
		});

		// All other Socket.io event listeners remain here
		socketRef.current.on("join-request", (requesterUserId: string) => {
			setIncomingCalls((prev) => [...prev, requesterUserId]);
			toast({ title: "Incoming Call", mode: "info", subtitle: `User ${requesterUserId} wants to join.` });
		});

		socketRef.current.on("room-created", (id: string) => {
			setRoomId(id);
			toast({ title: "Room Created", mode: "positive", subtitle: `Room ID: ${id}` });
		});

		socketRef.current.on("room-exists", () => toast({ subtitle: "", title: "Room Already Exists", mode: "negative" }));
		socketRef.current.on("room-unavailable", () =>
			toast({ subtitle: "", title: "Room Not Available", mode: "negative" })
		);
		socketRef.current.on("start-peer-connection", initializePeerConnection);

		socketRef.current.on("offer-request", async (data: { from: string; offer: RTCSessionDescriptionInit }) => {
			if (!peerRef.current) return;

			try {
				setRemoteSocketId(data.from); // Set ID before stream/offer logic

				const myStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
				localStreamRef.current = myStream;
				if (localVideoRef.current) localVideoRef.current.srcObject = myStream;

				myStream.getTracks().forEach((track) => peerRef.current?.addTrack(track, myStream));
				await peerRef.current.setRemoteDescription(new RTCSessionDescription(data.offer));
				const answer = await peerRef.current.createAnswer();
				await peerRef.current.setLocalDescription(answer);

				socketRef.current?.emit("offer-answer", { offer: answer, to: data.from });

				setCallActive(true);
				toast({ title: "Offer Received", mode: "info", subtitle: `From: ${data.from}` });
			} catch (err) {
				toast({ title: "Error handling offer", mode: "negative", subtitle: String(err) });
				console.error(err);
			}
		});

		socketRef.current.on("offer-answer", async (data: { offer: RTCSessionDescriptionInit }) => {
			if (!peerRef.current) return;
			await peerRef.current.setRemoteDescription(new RTCSessionDescription(data.offer));
			toast({ subtitle: "", title: "Answer Received", mode: "info" });
		});

		socketRef.current.on("peer-updated", async (data: { from: string; candidate: RTCIceCandidateInit }) => {
			if (!peerRef.current) return;
			try {
				await peerRef.current.addIceCandidate(new RTCIceCandidate(data.candidate));
				toast({ subtitle: "", title: "ICE Candidate Added", mode: "info" });
			} catch (e) {
				// Suppress common error when candidate arrives after closing call
			}
		});

		socketRef.current.on("call-ended", () => {
			closeCall(false);
			toast({ title: "Remote Peer Ended Call", mode: "info", subtitle: "" });
		});

		// Cleanup function for unmount
		return () => {
			// Cleanup socket listeners and close the call on component unmount
			socketRef.current.off("connect");
			socketRef.current.off("disconnect");
			closeCall(false); // Call cleanup logic
			socketRef.current?.disconnect();
		};
	}, [initializePeerConnectionAndListeners, closeCall, toast]); // closeCall is a dependency because it's used in disconnect handler

	// --- UI HANDLERS ---

	const createRoom = () => {
		if (!isConnected)
			return toast({ title: "Not Connected", mode: "negative", subtitle: "Wait for socket to connect." });
		if (!roomId) return toast({ subtitle: "", title: "Enter a room ID", mode: "negative" });
		// NOTE: The server should handle setting the creator flag, but keeping the local state for reference.
		socketRef.current?.emit("create-room", roomId);
	};

	const joinRoom = () => {
		if (!isConnected)
			return toast({ title: "Not Connected", mode: "negative", subtitle: "Wait for socket to connect." });
		if (!joinRoomId) return toast({ subtitle: "", title: "Enter a room ID", mode: "negative" });
		socketRef.current?.emit("join-video-room", joinRoomId);
	};

	const approveJoinRequest = (requesterUserId: string) => {
		socketRef.current?.emit("approve-join-request", roomId, requesterUserId);
		setIncomingCalls((prev) => prev.filter((id) => id !== requesterUserId));
		toast({ title: "Call Approved", mode: "positive", subtitle: `User ${requesterUserId} will connect.` });
	};

	const rejectJoinRequest = (requesterUserId: string) => {
		setIncomingCalls((prev) => prev.filter((id) => id !== requesterUserId));
		toast({ title: "Call Rejected", mode: "negative", subtitle: `User ${requesterUserId} was rejected.` });
	};

	// Wrapper for JSX button
	const handleCloseCall = () => closeCall(true);

	return (
		<>
			<h1 className="text-3xl font-bold underline">P2P Video Call</h1>
			<p className={`mb-4 text-sm font-semibold ${isConnected ? "text-green-500" : "text-red-500"}`}>
				Connection Status: {isConnected ? "🟢 Connected" : "🔴 Disconnected"}
			</p>
			<br />

			<div className="grid grid-cols-3 gap-4">
				<div className="mb-6" style={{ width: "300px" }}>
					<input
						type="text"
						value={roomId}
						onChange={(e) => setRoomId(e.target.value)}
						placeholder="Enter room id"
						className="form-input_custom__input form-input text-text" // Tailwind classes omitted for brevity
					/>
					<br />
					<button
						onClick={createRoom}
						disabled={!isConnected} // ⚠️ Disabled if socket isn't connected
						className="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 disabled:bg-gray-400"
					>
						Create new room
					</button>
				</div>

				<div className="mb-6">
					<input
						type="text"
						value={joinRoomId}
						onChange={(e) => setJoinRoomId(e.target.value)}
						placeholder="Enter room id to join"
						className="form-input_custom__input form-input text-text" // Tailwind classes omitted for brevity
					/>
					<br />
					<button
						onClick={joinRoom}
						disabled={!isConnected} // ⚠️ Disabled if socket isn't connected
						className="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 disabled:bg-gray-400"
					>
						Join existing room
					</button>
					<button
						className="text-white bg-red-500 hover:bg-red-600 focus:ring-4 focus:outline-none focus:ring-red-300 font-medium rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center ml-2 disabled:bg-gray-400"
						onClick={handleCloseCall}
						disabled={!callActive}
					>
						End Call
					</button>
				</div>

				<div className="relative overflow-x-auto">
					{/* Incoming Calls List (omitted for brevity) */}
					{incomingCalls.length > 0 && (
						<table className="w-full text-sm text-left rtl:text-right text-gray-500 dark:text-gray-400">
							{/* ... table content ... */}
						</table>
					)}
				</div>
			</div>

			<div className="grid grid-cols-2 gap-4 mt-6">
				{callActive && (
					<>
						<div>
							<p className="text-center font-semibold mb-2">My Video (Muted)</p>
							<video ref={localVideoRef} autoPlay muted className="w-full rounded-lg border-2 border-blue-500" />
						</div>
						<div>
							<p className="text-center font-semibold mb-2">Remote Video</p>
							<video ref={remoteVideoRef} autoPlay className="w-full rounded-lg border-2 border-green-500" />
						</div>
					</>
				)}
			</div>
		</>
	);
}
